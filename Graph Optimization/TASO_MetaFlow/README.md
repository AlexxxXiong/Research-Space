# TASO: Optimizing Deep Learning Computation with Automatic Generation of Graph Substitutions

TASO 是 Unity 的主要前作，更为**详细地阐述了如何进行替代生成、替代验证，以及剪枝冗余的替代**，**复用了 MetaFlow 提出的基于开销的回溯搜索算法**，并**拓展了对 tensor 在内存中 data layout 的枚举优化**。

-------------

###### Part 1. 计算图中图替代的生成、验证和剪枝

**替代生成**：**通过 DFS 迭代添加 OP，枚举计算图，再计算两步哈希的指纹，指纹相同的二次验证**

- Step 1. 在现有图中**迭代添加 OP**，通过**枚举 OP 类型及 tensor 输入**，**通过 DFS 算法来构造所有的非循环且不包含重复计算的计算图**（若某个图中存在两个 OP 对相同输入 tensor 进行了相同的计算，则定义为包含重复计算）；同时用随机 tensor 和常数 tensor 作为输入，来查找涉及常数 tensor 的替代（如单位矩阵的 OP，输出等于输入，是一个常数替代）；为了避免计算指纹时的 FLOP 精度损失，**所有 tensors 都被表示为整数**（已有工作）；**两步哈希函数**：计算每个计算图的指纹。先对图的每个输出 tensor 考虑 size、shape 和 content 地计算一次哈希，再对所有输出 tensor 的第一次哈希值无序地进行第二次对称哈希；
- Step 2. **对于拥有相同指纹的两个图，TASO 会进一步在一系列 test case 上检测**。每个 case 包含一系列随机输入 tensor，**若两个图的输出 tensor 相差小于一个阈值则通过**（未和计算指纹时一样使用整数化）；存在**两类 OP 需要特殊处理**：1) **relu**，对所有负输入总返回 0，造成许多无用的替代被判定为合法，因此使用一个随机非线性函数来在图计算中替代 relu；2) **enlarge**，通过 padding，也会造成无用替代被判定为合法，仅考虑将 enlarge 用在输入 tensor 的计算图；

**替代验证**：这里的 **OP 性质还是人工设置并检测的**，Unity 里面也是。

- **OP 性质的验证步骤**：TASO **在小范围内所有参数值和 tensor size 上验证 OP 性质**，因此需要**在 Python 中将每个 tensor OP 表示为基础的符号化实现**；然后**用 Z3 证明器来验证 OP 性质**；

**冗余替代剪枝**：图替代是冗余的，**若其被一个更加通用的合法替代所包含**，其也是剪枝的目标；剪枝操作会**保留潜在的优化可能**：若图 G 可以通过一系列替代转换为 G'，则剪枝后也可以；

- Step 1. 消除所有**可通过输入 tensor 重命名而等价的替代**；
- Step 2. **相同子图**：
    - Type 1. 若合法，**将源和目标图内的相同子图替换为一个新的输入 tensor**，更加通用；
    - Type 2. 若合法，**将源和目标图内包含所有输出的相同子图去除**，将该子图的相同输入作为源和目标图的新输出，更加通用；

------

###### Part 2. MetaFlow 基于开销的回溯搜索算法

**基于开销的回溯搜索算法 (MetaFlow)** ：使用 MetaFlow 提出的基于开销的回溯搜索算法，并**基于源图的数据布局和目标图内 OP 支持的布局**，**枚举目标图可能的数据布局**；**cost 模型** 和 OptCNN 及 FlexFlow 一致（大概），基于  OP 进行密集线性且无分支代数计算的事实，因此其在硬件上的性能是高度连续且可预测的（给定数据布局和配置参数）；如 MetaFlow 和 FlexFlow 一样，**测单个 OP 然后加**；图替代可能会导致环的产生，因此**在将 G' 入队前要先检查是否有环**。（具体回溯算法见 Unity note 里的介绍）

------

###### Part 3. 总结

整篇 paper 最 fancy 的地方在于**对图替代生成、验证和冗余替代剪枝的阐述**，是 Unity 的基础。
